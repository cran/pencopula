\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8,latin1]{inputenc}
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `pencopula'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\item[Type]\AsIs{Package}
\item[Title]\AsIs{Flexible Copula Density Estimation with Penalized Hierarchical B-Splines}
\item[Version]\AsIs{0.3}
\item[Date]\AsIs{2011-06-27}
\item[Depends]\AsIs{R (>= 2.8.0), lattice, fda, quadprog, spam}
\item[Author]\AsIs{Christian Schellhase \email{cschellhase@wiwi.uni-bielefeld.de}}
\item[Maintainer]\AsIs{Christian Schellhase \email{cschellhase@wiwi.uni-bielefeld.de}}
\item[Description]\AsIs{Flexible copula density estimation with penalized hierarchical B-Splines.}
\item[License]\AsIs{GPL (>= 2)}
\item[LazyLoad]\AsIs{yes}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{pencopula-package}{The package 'pencopula' offers routines for estimating multivariate penalized copula densities and copula distribution.}{pencopula.Rdash.package}
\keyword{nonparametric}{pencopula-package}
%
\begin{Description}\relax
The package 'pencopula' offers routines for estimating multivariate penalized copula densities and copula distribution. For details see the description of the function pencopula().
\end{Description}
%
\begin{Details}\relax

\Tabular{ll}{
Package: & pencopula\\{}
Type: & Package\\{}
Version: & 0.3\\{}
Date: & 2011-06-27\\{}
License: GPL (>= 2)
LazyLoad: & yes\\{}
}
The packages contributes the function 'pencopula()' for estimating copula densities and copula distributions using penalized splines techniques. 
\end{Details}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
Y <- cbind(runif(200),runif(200))
plot(pencopula(Y,d=4,D=4,lambda=rep(100000,2),base="B-spline"))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bernstein}{Calculating a bernstein polynomial.}{bernstein}
\aliasA{int.bernstein}{bernstein}{int.bernstein}
\keyword{math}{bernstein}
%
\begin{Description}\relax
Calculating a bernstein polynomial, transformed to be a
density. 'int.bernstein' calculates the integral of the bernstein
density polynomial.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bernstein(v,x,n)
int.bernstein(x,n)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{v}] number of the current basis element, e.g. v is in the interval [0,2\textasciicircum{}K]
\item[\code{x}] data points for constructing of the bernstein polynomial basis.
\item[\code{n}] number of polynomials in the bernstein polynomial basis, e.g n = 2\textasciicircum{}K   
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The bernstein polynomial density basis is created using the function 'apply'
for some data 'x'.

K <- 3
index.b <- matrix(0:2\textasciicircum{}K)
\#\# Bernstein polynomial 
B <- apply(index.b,1,bernstein,x,n=2\textasciicircum{}K)

The integral of the Basis B of degree n is:
B <- int.bernstein(x,n=2\textasciicircum{}K)
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
\inputencoding{utf8}
\HeaderA{Derv1}{Calculating the first derivative of the pencopula likelihood function w.r.t. parameter b}{Derv1}
\keyword{math}{Derv1}
%
\begin{Description}\relax
Calculating the first derivative of the pencopula likelihood function w.r.t. parameter b. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Derv1(penden.env)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{penden.env}] Containing all information, environment of pencopula().
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The calculation of the first derivative of the pencopula likelihood function w.r.t. b equals
\deqn{s(b,\lambda)= {\partial l(b,\lambda)}/{\partial b}= \sum_{i=1}^n
  \Phi(u_i)/c(u_i,b) - P(\lambda)b}{}
with \deqn{P(\lambda)}{}
is the penalty matrix, saved in the environment.
\end{Details}
%
\begin{Value}
\begin{ldescription}
\item[\code{Derv1.pen}] first order derivation of the penalized likelihood
function w.r.t. parameter b.
\end{ldescription}
Derv1.pen is saved in the environment.
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert,
D. (2011), to appear.
\end{References}
\inputencoding{utf8}
\HeaderA{Derv2}{Calculating the second order derivative with and without penalty.}{Derv2}
\keyword{math}{Derv2}
%
\begin{Description}\relax
Calculating the second order derivative of the likelihood function of
the pencopula approach w.r.t. the parameter b. Thereby, for later use,
the program calculates the second order derivative with and without the
penalty. Moreover, Derv2 seperates the calculation for temporary weights
b in iteration and final weights b.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
Derv2(penden.env, temp = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{penden.env}] Containing all information, environment of pendensity()
\item[\code{temp}] smoothing parameter lambda
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
We approximate the second order derivative in this approach with the negative fisher information. 
\end{Details}
%
\begin{Value}
\begin{ldescription}
\item[\code{Derv2.pen}] second order derivative w.r.t. beta with penalty
\item[\code{Derv2.cal}] second order derivative w.r.t. beta without
penalty. Needed for calculating of e.g. AIC.
\end{ldescription}
Derv2.cal and Derv2.pen are saved in the environment.
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
\inputencoding{utf8}
\HeaderA{DeutscheBank}{Daily final prices (DAX) of the German stock Deutsche Bank in the years 2006 and 2007}{DeutscheBank}
\keyword{datasets}{DeutscheBank}
%
\begin{Description}\relax
Containing the daily final prices of the German stock Deutsche Bank in the years 2006 and 2007.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(DeutscheBank)
\end{verbatim}
\end{Usage}
%
\begin{Format}
A data frame with 507 observations of the following 2 variables.
\begin{description}

\item[\code{Date}] Date
\item[\code{ClosingPrice}] ClosingPrice

\end{description}

\end{Format}
\inputencoding{utf8}
\HeaderA{distr.func.help}{These functions are used for calculating the integral of the
 B-spline density basis.}{distr.func.help}
\aliasA{poly.part}{distr.func.help}{poly.part}
\keyword{math}{distr.func.help}
%
\begin{Description}\relax
These functions cooperate with each other for calculating the
integral of the B-spline density basis. functions. 'distr.func.help' is the main program, calling
'poly.part', calculating the integral of the B-spline density basis in sections between neighbouring knots. 'distr.func.help' calculates analytical functions of the integral. Therefore the function 'poly.part' is needed to construct these functions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
distr.func.help(base,knots,penden.env,q,y,index)
poly.part(i,j,knots,help.env,q, yi=NULL, poly=FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{base}] values of the considered B-spline basis
\item[\code{knots}] knots of the considered B-spline basis
\item[\code{penden.env}] Containing all information, environment of pencopula()
\item[\code{q}] degree of the B-Spline basis
\item[\code{y}] data of the marginal B-spline basis
\item[\code{index}] columns of the whole B-spline basis, each hierarchy level
is integrated separately
\item[\code{i}] internal values for calculating the polynomials of each B-Spline
\item[\code{j}] internal values for calculating the polynomials of each
B-Spline
\item[\code{help.env}] internal environment of pencopula() for calculating
the integral
\item[\code{yi}] internal values for calculating the polynomials of each
B-Spline
\item[\code{poly}] internal value, TRUE/FALSE
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\begin{ldescription}
\item[\code{distr.func.help}] creating environment 'help.env', creating help points between each two neighbouring knots and calculates the integral each basis
\item[\code{poly.part}] using in 'distr.func.help' for creating the polynomial functions of each interval of each two neighbouring knots
\end{ldescription}
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
\inputencoding{utf8}
\HeaderA{f.hat.val}{Calculating the actual fitted values 'f.hat.val' of the estimated density function}{f.hat.val}
\keyword{nonparametric}{f.hat.val}
%
\begin{Description}\relax
Calculating the actual fitted values of the response, depending on the actual parameter set b
\end{Description}
%
\begin{Usage}
\begin{verbatim}
f.hat.val(penden.env,cal=FALSE,temp=FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{penden.env}] Containing all information, environment of pencopula()
\item[\code{cal}] if TRUE, the final weights of one iteration are used for
the calculation of the fitted values.
\item[\code{temp}] if TRUE, the iteration for optimal weights is still in
progress and the temporary weights are used for calculation of the
fitted values.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Calculating the actual fitted values of the response, depending on the actual parameter set b. Multiplying the actual set of parameters \eqn{b}{} with the base 'base.den' delivers the fitted values.
\end{Details}
%
\begin{Value}
\begin{ldescription}
\item[\code{f.hat.val}] Fitted values for the current coefficents\end{ldescription}
.
f.hat.val is saved in the environment.
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
\inputencoding{utf8}
\HeaderA{hierarch.bs}{Construction of the hierarchical B-spline density basis.}{hierarch.bs}
\keyword{nonparametric}{hierarch.bs}
%
\begin{Description}\relax
Construction of the hierarchical B-spline density basis.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
hierarch.bs(x, d, plot.bsp, typ, penden.env, int=FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Marginal data for construction.
\item[\code{d}] Hierarchy level of the marginal hierarchical B-spline density.
\item[\code{plot.bsp}] Default = FALSE. If TRUE, each B-spline basis is plotted.
\item[\code{typ}] typ==1 without open B-splines at the boundary
typ==2 with open B-splines at the boundary.
\item[\code{penden.env}] Containing all information, environment of pencopula().
\item[\code{int}] Default = FALSE. If TRUE, the integral of the hierarchical
B-spline density basis is calculated (used for the distribution
function of the estimation).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
First, the marginal hierarchical B-spline density basis is constructed for each
covariate 'B.tilde'.

After the construction of each marginal basis, the
hierarchical B-spline density basis is built in the main program
pencopula(), using an object  'Index.basis.D' (saved in the
environment). 'Index.basis.D' notes which compenent of the marginal
basis has to be selected. In the main program the object
'tilde.Psi.d.D' is constructed. D refers to the maximum hierachy level
and 'd' is the hierarchy level of the marginal hierarchical B-spline.
\end{Details}
%
\begin{Value}
\begin{ldescription}
\item[\code{B.tilde}] 'B.tilde' is the hierarchical B-spline density basis,
returned by 'hierarch.bs'.
\item[\code{int.B.tilde}] If 'int=TRUE', the integral of the hierachical
B-spline density basis is calculated and returned by 'hierarch.bs'.
\end{ldescription}
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
\inputencoding{utf8}
\HeaderA{knots.start}{Calculating the knots.}{knots.start}
\aliasA{knots.order}{knots.start}{knots.order}
\aliasA{knots.transform}{knots.start}{knots.transform}
%
\begin{Description}\relax
Calculating the equidistant knots for the estimation. Moreover,
transformation of the knots are possible.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  knots.start(penden.env)
  knots.transform(d,alpha = 0, symmetric = TRUE)
  knots.order(penden.env)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{penden.env}] Containing all information, environment of
pencopula()
\item[\code{d}] Hierarchy level of the marginal hierarchical B-spline basis.
\item[\code{alpha}] Default = 0. Alpha is a tuning parameter, shifting the
knots.
\item[\code{symmetric}] Default = TRUE. If FALSE, the knots are selected
without symmetry.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
'Knots.order' sorts the knots in the order, in which they disappear
in the hierarchical B-spline basis.
\end{Details}
%
\begin{Value}
\begin{ldescription}
\item[\code{knots}] Selected and sorted marginal knots for the estimation.
\item[\code{knots.help}] Extended set of knots. It is needed for calculating the distribution
function, help points for the integration of the B-spline density basis.
\item[\code{k.order}] Order of the knots, corresponding to their order in the
hierarchical B-spline density basis.
\item[\code{knots.t}] The knots ordered with 'k.order' for further fucntions.
\item[\code{tilde.Psi.knots.d}] Hierarchical B-Spline density basis for 'knots'.
\item[\code{tilde.Psi.knots.d.help}] Hierarchical B-Spline density basis for
'knots.help'.
\end{ldescription}
All values are saved in the environment.
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
\inputencoding{utf8}
\HeaderA{Lufthansa}{Daily final prices (DAX) of the German stock Lufthansa in the years 2006 and 2007}{Lufthansa}
\keyword{datasets}{Lufthansa}
%
\begin{Description}\relax
Containing the daily final prices of the German stock Lufthansa in the years 2006 and 2007.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(Lufthansa)
\end{verbatim}
\end{Usage}
%
\begin{Format}
A data frame with 507 observations of the following 2 variables.
\begin{description}

\item[\code{Date}] Date
\item[\code{ClosingPrice}] ClosingPrice

\end{description}

\end{Format}
\inputencoding{utf8}
\HeaderA{my.bspline}{my.bspline}{my.bspline}
\aliasA{int.my.bspline}{my.bspline}{int.my.bspline}
\keyword{math}{my.bspline}
%
\begin{Description}\relax
'my.bspline' Integrates the normal B-Spline basis to a B-spline density
basis. The dimension of the basis depends on the input of number of
knots 'k' and of the order of the B-spline basis 'q'. 'int.my.bspline'
is a function for transformation of open B-spline basis at the
boundary to become a B-spline basis density.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
my.bspline(h, q, knots, y, K, plot.bsp, typ)
int.my.bspline(help.env)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{h}] if equidistant knots are used (default in pencopula()), h is the distance between two neighbouring knots
\item[\code{q}] selected order of the B-spline basis
\item[\code{knots}] selected values for the knots
\item[\code{y}] values of the response variable
\item[\code{K}] the number of knots for the construction of the base
\item[\code{plot.bsp}] Indicator variable TRUE/FALSE if the integrated
B-spline basis should be plotted
\item[\code{typ}] typ==1 without open B-splines at the boundary
typ==2 with open B-splines at the boundary
\item[\code{help.env}] Internal environment of my.bspline().
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Firstly, the function constructs the B-spline basis to the given number
of knots 'K' and the given locations of the knots. Due
to the recursive construction of the B-Spline, for all orders greater
than 2, the dimension of the B-spline basis of given K grows up with
help.degree=q-2.
There are two typs of B-spline basis possible. First, a B-spline basis
without open B-splines at the boundary (typ==1) and a regulat B-spline
basis with open B-splines at the boundary (typ==2).
Both typs are integrated to become B-spline density basis. To
integrate a basis of typ 1 we use the well-known factor
'q/(knots.val[i+q]-knots.val[i])'. For typ==2 we determine
functions analytically for the integration.
Moreover, one can draw the integrated basis and, if one calls this function with the argument 'plot.bsp=TRUE'.
\end{Details}
%
\begin{Value}
\begin{ldescription}
\item[\code{base.den}] The integrated B-Spline base of order q
\item[\code{stand.num}] The coefficients for standardization of the ordinary B-Spline basis
\item[\code{knots.val}] This return is a list. It consider of the used knots 'knots.val\bsl{}\$val', the help knots 'knots.val\bsl{}\$help' and the additional knots 'knots.val\bsl{}\$all', used for the construction of the base and the calculation of the distribution function of each B-Spline.
\item[\code{K}] The transformed value of K, due to used order 'q' and the input of 'K'
\end{ldescription}
\end{Value}
%
\begin{Note}\relax
This functions uses the fda-package to build the B-Spline density basis.
\end{Note}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
\inputencoding{utf8}
\HeaderA{my.IC}{Calculating the AIC- and BIC-value}{my.IC}
\keyword{math}{my.IC}
%
\begin{Description}\relax
Calculating the AIC- and BIC- value of the copula density estimation. Therefore, we add the unpenalized log likelihood of the estimation and the degree of freedom, which are 	
\end{Description}
%
\begin{Usage}
\begin{verbatim}
my.IC(penden.env)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{penden.env}] Containing all information, environment of pencopula()
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
AIC is calculated as
\eqn{AIC(\lambda)= - 2*l({\bf u},\hat{\bf{b}}) + 2*df(\lambda)}{}

BIC is calculated as
\eqn{BIC(\lambda)= 2*l({\bf u},\hat{\bf{b}}) + 2*df(\lambda)*log(n)}{}
\end{Details}
%
\begin{Value}
\begin{ldescription}
\item[\code{AIC}] sum of twice the negative non-penalized log likelihood and mytrace
\item[\code{trace}] calculated mytrace as the sum of the diagonal matrix
df, which results as the product of the inverse of the penalized
second order derivative of the log likelihood with the non-penalized
second order derivative of the log likelihood
\item[\code{BIC}] sum of twice the non-penalized log likelihood and log(n)
\end{ldescription}
All values are saved in the environment.
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
\inputencoding{utf8}
\HeaderA{my.loop}{Iterative loop for calculating the optimal coefficients 'b'.}{my.loop}
\keyword{math}{my.loop}
%
\begin{Description}\relax
Calculating the optimal coefficients 'b' iteratively, using quadratic programing.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
my.loop(penden.env)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{penden.env}] Containing all information, environment of pencopula()

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
'my.loop' optimates the log-likelihhod iteratively. Therefore, the
routine checks the relative chance in the weights and stops the
iteration, if the relative change of all weights 'b' is less than one
percent. During the calculations of new weights 'b' in the routine
'new.weights', most of the values are called '.temp'. This add on
unterlines the temporarily values. 'my.loop' checks the relative
change in the weights. If the change is greater than one percent, the
the real values are overwritten with the '.temp' values.
\end{Details}
%
\begin{Value}
\begin{ldescription}
\item[\code{liste}] The results of each iteration are written in a matrix called 'liste',
saved in the environment. 'liste' contains the penalized
log-likelihood, the log-likelihood, 'lambda' and the weights 'b'.
\end{ldescription}
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
\inputencoding{utf8}
\HeaderA{new.weights}{Calculating new weights b.}{new.weights}
\keyword{nonparametric}{new.weights}
%
\begin{Description}\relax
Calculating new weights b using quadratic programing.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
new.weights(penden.env)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{penden.env}] Containing all information, environment of pencopula()
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The new weights are calculated solving a quadratic program. Therefore,
the derivates of first and second order are needed, 'Derv1.pen' and
'Derv2.pen'. Moreover, we have to fulfill the side conditions
c(u,b)>=0, sum(b)=1 and that the marginal density is uniform. All side
conditions are saved as 'AA.help' in the environment. There exists two
different algorithms, due to the fact if one works with or without an
adaptive grid for the side condition c(u,b)>=0.

If the quadratic program does not find a new feasible solution, the whole
program terminates. For solving the quadratic program, we use the
function 'solve.QP' from the  R-package 'quadprog'. 
\end{Details}
%
\begin{Value}
\begin{ldescription}
\item[\code{ck.val.temp}] Calculated new values for the weights 'b'. The add
on 'temp' means, that there is a check in the next step if the
weights 'b' have been converted or not. If converted, the new values
'ck.val.temp' are unnoted. If not converted, 'ck.val.temp' become
the ordinary 'ck.val' for the next iteration. This check is done in my.loop.
\end{ldescription}
'ck.val.temp' is saved in the environment.
\end{Value}
%
\begin{Note}\relax
For high dimensional data (p>=4) and high hierachy level 'd' of the
marginal hierarchical B-spline, the computational time for solving a
quadratic program increases.

\end{Note}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
\inputencoding{utf8}
\HeaderA{pen.log.like}{Calculating the log likelihood}{pen.log.like}
\keyword{nonparametric}{pen.log.like}
%
\begin{Description}\relax
Calculating the considered log likelihood.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pen.log.like(penden.env, cal=FALSE, temp=FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{penden.env}] Containing all information, environment of pencopula()
\item[\code{cal}] if TRUE, the final weights of one iteration are used for
the calculation of the penalized log likelihood.
\item[\code{temp}] if TRUE, the iteration for optimal weights is still in
progress and the temporary weights are used for calculation.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The calculation depends on the estimated weights b, the penalized
hierarchical B-splines Phi and the penalty paramters lambda.\\{}
\deqn{l(b,\lambda)=\sum_{i=1}^{n} \left[ \log \{\sum_{i=1}^n
  \boldsymbol\Phi(u_i)\} b\right]- \frac 12 b^T \boldsymbol{P}(\lambda) b}{}
with
\deqn{\boldsymbol{P}(\lambda)=\sum_{j=1}{p}\lambda_j\boldsymbol{P}_j}{}

The needed values are saved in the environment.
\end{Details}
%
\begin{Value}
\begin{ldescription}
\item[\code{pen.log.like}] Penalized log likelihood of the copula density.
\item[\code{log.like}] Log-Likelihood of the copula density.
\end{ldescription}
The values are saved in the environment.
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
\inputencoding{utf8}
\HeaderA{penalty.matrix}{Calculating the penalty matrix P(lambda)}{penalty.matrix}
\keyword{nonparametric}{penalty.matrix}
%
\begin{Description}\relax
Calculating the penalty matrix P depends on the number of
covariates 'p', the order of differences to be penalized 'pen.order',
the number of observations 'n' and the penalty parameters 'lambda''.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
penalty.matrix(penden.env, temp = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{penden.env}] Containing all information, environment of
pencopula().
\item[\code{temp}] If TRUE, the iteration for a new 'b' is not finished and a temporary penalty matrix is calculated, default = FALSE.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The penalty matrix is calculated as

\eqn{P=\sum_{j=1}^{p} \lambda_j P(\lambda)_j}{}

with

\eqn{P(\lambda)_j=\left(\bigotimes_{l=1}^{j-1}{I}\right) \otimes \{({A^{-1})^T} P {A}^{-1}\} \otimes \left(\bigotimes_{l=j+1}^p {I}\right)}{}

The needed values are calculated or saved in the environment 'penden.env'.
\end{Details}
%
\begin{Value}
\begin{ldescription}
\item[\code{DDD.sum}] Penalty matrix P
\end{ldescription}
Matrix is saved in the environment.
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
\inputencoding{utf8}
\HeaderA{pencopula}{Calculating penalized copula density with penalized hierarchical B-splines}{pencopula}
\keyword{nonparametric}{pencopula}
%
\begin{Description}\relax
Main program for estimation of copula densities with penalized
hierarchical B-splines. The estimation can be done for multivariate
datasets. The response is called 'y', the covariates 'x'. We estimate
densities using penalized hierarchical B-splines. This is done by
choosing the polynomial degree of the univariate B-spline density
basis, that is built uopn 2\textasciicircum{}d+1 equidistant knots. 'd' refers to the
hierachy level of the marginal hierarchical  B-spline and 'D' to the
maximum hierarchical level of the hierarchical B-spline basis. We penalize the m-order differences of the coefficients 'b' to estimate new weights 'b'.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pencopula(data, d=3, D=d, q=1, base = "B-spline", max.iter = 20,
plot.bsp = FALSE, lambda = NULL, pen.order=2, adapt.grid = FALSE, add =
TRUE, alpha = 0, symmetric= TRUE, data.frame=parent.frame())
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] 'data' contains the data. 'data' has to be a matrix or a
data.frame. The number of columns of 'data' is p.
\item[\code{d}] refers to the hierachy level of the marginal hierarchical
B-spline, default is d=3.
\item[\code{D}] referes to the maximum hierachy level, default is D=3. If
D<d, it follows D<-d.
\item[\code{q}] degree of the marginal hierarchical B-spline.
\item[\code{base}] By default, the used marginal basis is a
'B-spline'. Second possible option is 'Bernstein', using a Bernstein
polynomial basis.
\item[\code{max.iter}] maximum number of iteration, the default is max.iter=20.
\item[\code{plot.bsp}] TRUE or FALSE, if TRUE the used B-Spline base should
be plotted.
\item[\code{lambda}] p-dimensional vector of penalty parameters, the values
can be different. Default is rep(10000,p).
\item[\code{pen.order}] The order of differences for the penalization,
default is pen.order=2.
\item[\code{adapt.grid}] Default = FALSE, if TRUE the used grid for the side
condition c(u,b)>=0 is reduced.
\item[\code{add}] Default = TRUE. Due to numerical rounding errors, some
results in the quadratic programming are misleading. So we add a
small epsilon in the side conditions c(u,b) >=0 to the actual weights 'b' in each iteration.
\item[\code{alpha}] Default = 0, that results in equidistant knots. If alpha
!=0 the knots are moved.
\item[\code{symmetric}] Default = TRUE. Tuning parameter for the location of
the knots if alpha != 0.
\item[\code{data.frame}] reference to the data. Default reference is the parent.frame().
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The estimation of the copula density is done in several steps.
1. Preparations: Calculating the number of marginal knots 'ddb' and the
number of spline coefficients 'DD' , depending on 'd' and
'D'.'Index.Basis.D' is created, that is an index set,
which marginal basis will belong to the hierarchical B-spline density
basis 'tilde.Psi.d.D'.
2. Creating marginal spline coefficients 'T.marg', depending on
'Index.basis.D'.
3. Building the hierarchical B-spline density basis 'tilde.PSI.d.D'
4. Calculating the knots for the estimation, by default the knots are
equidistant. Transformations of the knots are possible, see
'knots.start'. Moreover a B-spline density basis 'tilde.Psi.d.knots'
is created, with the knots in the hierachical order
'knots.t'. 'tilde.Psi.d.knots' is needed for the restriction, that
each marginal density has to be uniform.
5. Depending on the knots, start values for the weights 'b' are
calculated. This is done in 'startval.grid'. Moreover 'startval.grid'
determines an grid for the side condition c(u,b)>=0 of the quadratic
program.
6. Each marginal basis is estimated to be uniform. Therefore a matrix
'A.Restrict' is calculated, such that \deqn{A.Restrict \%*\% b = 1}{}
for all p-covariates.
7. The penalty matrix P is created, see 'penalty.matrix'.
8. The first calculation of coefficients 'b' is done.
9. 'my.loop' iterates the calculation of the optimal weights 'b' until
some convergence, see 'my.loop'. The maximal number of iterations are
limited, default is max.iter=20.
10. If 'my.loop' terminates, the information criteria are calculated,
see 'my.IC'.
\end{Details}
%
\begin{Value}
Returning an object of class pencopula. The class pencopula consists of
the environment 'penden.env', which includes all calculated values of
the estimation approach.
For a fast overview of the main results, one can use the function 'print.pencopula()'.
\end{Value}
%
\begin{Note}\relax
If the estimation with the current setup does not work, e.g. the
quadratic program can not be solved, the routine returns log.like=0, pen.log.like=0,
AIC=0 and BIC=0. Please restart the estimation, e.g. with a different
penalty parameter.
\end{Note}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
%
\begin{Examples}
\begin{ExampleCode}

data(Lufthansa)
data(DeutscheBank)

data.dbank <- data.lufth <- c()

dim.data <- dim(DeutscheBank)[1]

for(i in 2:dim.data) data.dbank[i-1] <- DeutscheBank[i,2]/DeutscheBank[i-1,2]
for(i in 2:dim.data) data.lufth[i-1] <- Lufthansa[i,2]/Lufthansa[i-1,2]

dbank1 <- rank(data.dbank)/(length(data.dbank)+1)
lufth1 <- rank(data.lufth)/(length(data.lufth)+1)

Y <- cbind(dbank1,lufth1)

cop <- pencopula(Y,d=4,D=4,lambda=rep(50000,2))

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{pendenForm}{Formula interpretation and data transfer}{pendenForm}
\keyword{IO}{pendenForm}
%
\begin{Description}\relax
Function 'pendenForm' interprets the input 'form' of the function pencopula(),transfers the data back to the main program.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pendenForm(penden.env)

\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{penden.env}] environment used in pendensity()
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Returning the values 'Y', the number of values 'n' and covariates 'p'.
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
\inputencoding{utf8}
\HeaderA{plot.pencopula}{Plot the estimated copula density or copula distribution.}{plot.pencopula}
\keyword{plot}{plot.pencopula}
%
\begin{Description}\relax
The function plots the estimated copula density or the
copula distrubtion, using the R-package 'lattice'.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plot.pencopula(x, val = NULL, marg = TRUE, plot = TRUE, int = FALSE,
main.txt = NULL, sub.txt = NULL, contour = FALSE, cond = NULL, cuts =
20, cex = 1, cex.axes = 1, xlab = NULL, ylab = NULL, zlab=NULL,...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] object of class 'pencopula'.
\item[\code{val}] Default val = NULL, one can calculate the estimated density
in for p-dimensional vector, e.g. val=c(0.5,1) for the two
dimensional case.
\item[\code{marg}] Default = TRUE, plotting the marginal densities.
\item[\code{plot}] Default = TRUE, if 'FALSE' no plot is shown, e.g. for
calculations with val != NULL.
\item[\code{int}] Default = FALSE, if TRUE, the integral, i.e. the distribution of
the copula density is plotted.
\item[\code{main.txt}] Default = NULL shows 'd', 'D', the values of lambda,
the penalty order and the degree of the B-splines.
\item[\code{sub.txt}] Default = NULL shows the log-likelihood, the penalized
log-likelihood and the AIC-value of the estimation.
\item[\code{contour}] If TRUE, a contour plot is shown. Default = FALSE.
\item[\code{cond}] Default = NULL, if the dimension of data 'p' is higher
than 2, one can plot a two-dimensional conditional plot. The user
specifies p-2 values for the plot, indicating with '-1'. So for a
three-dimensional plot, cond=c(0,-1,-1) shows the
density/distribution  ith fixed first covariate and the second
and third covariates vary.
\item[\code{cuts}] Number of cuts for the contour plots, if contour=TRUE.
\item[\code{cex}] Default = 1, determing the size of the main of the plot.
\item[\code{cex.axes}] Default = 1, determing the size of the labels at the axes.
\item[\code{xlab}] Default = NULL and no text is printed at the xlab
\item[\code{ylab}] Default = NULL and no text is printed at the ylab
\item[\code{zlab}] Default = NULL and 'density' is printed at the zlab for
int=FALSE and 'distribution' for int=TRUE.
\item[\code{...}] further arguments
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
For the two dimensional plots, a equidistant grid of 21 values between
0 and 1 is constructed. The plot consists of the density or
distribution values in this grid points. For plots of high dimensional
data (p>2), one has to fix p-2 covariates (see 'cond').
\end{Details}
%
\begin{Value}
If 'val' is not NULL, the function returns a matrix with the
calculated density or distribution values for the set 'val'.
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
\inputencoding{utf8}
\HeaderA{print.pencopula}{Printing the main results of the penalized copula density estimation}{print.pencopula}
\aliasA{print}{print.pencopula}{print}
\keyword{print}{print.pencopula}
%
\begin{Description}\relax
Printing the call of the estimation, the used basis, lambda and
the corresponding values of AIC and BIC. Need an object of class pencopula.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S3 method for class 'pencopula':
print(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] x has to be object of class pencopula
\item[\code{...}] further arguments
\end{ldescription}
\end{Arguments}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
\inputencoding{utf8}
\HeaderA{start.valgrid}{Calculating the start values 'b' for the first iteration of the
 quadratic program.}{start.valgrid}
\aliasA{grid.points}{start.valgrid}{grid.points}
\keyword{nonparametric}{start.valgrid}
%
\begin{Description}\relax
Calculating the start values 'b' for the first iteration of the
quadratic program. Moreover, the grid of values for the side condition
c>=0 of the quadratic program are calculated. If "adapt.grid", the
number of grid points is reduced to speed up the quadratic program.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
start.valgrid(penden.env)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{penden.env}] Containing all information, environment of pencopula()
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The grid of values for the side conditions of the quadratic
program c>=0 is constructed as the tensor product of all knots. If \$p\$
and \$d\$ increase, the number of conditions and computational time of
the quadratic programm increase enormously, e.g. a full tensor product
\$u\$ for \$p=4\$ and \$d=4\$ contains 83521 entries. If the data
\$u\$ is not high correlated, i.e. the data is not from a extreme
value copula like a Clayton copula, one can reduce the full tensor
product. In 'pencopula' one can choose the option
'adapt.grid' which effects the following and may reduce the
calculating time without any loss of accuracy. One can omit points in
\$u\$ in sections of \$[0,1]\textasciicircum{}p\$ which are in the neighbourhood
of many observations in \$u\$, because the data itself induces a
positive density in these areas by construction. Therefore, we
calculate the minimal \$p\$-dimensional euclidean distance \$e\_i\$
of each \$u\_i, i=1,\dots,(2\textasciicircum{}d+1)\textasciicircum{}p\$ to the data \$u\$ and omit the points
corresponding to the first quartile of minimal euclidean distance
\$e\_i\$ in \$u\$, we call this new set of points
\$u\_min\$. This amout of points is used in the first
iteration step to estimate weights \$b\$ corresponding to a copula
density.
\end{Details}
%
\begin{Value}
\begin{ldescription}
\item[\code{X.knots.g}] If adapt.grid=TRUE, set of reduced grid values, in which the side condition of
the quadratic program c(u,b)>=0 will be postulated.
\item[\code{X.knots.g.all}] Set of all grid values, in which the side condition of
the quadratic program c(u,b)>=0 will be postulated.
\end{ldescription}
The values are saved in the environment.
\end{Value}
%
\begin{Author}\relax
Christian Schellhase <cschellhase@wiwi.uni-bielefeld.de>
\end{Author}
%
\begin{References}\relax
Flexible Copula Density Estimation with Penalized
Hierarchical B-Splines, Kauermann G., Schellhase C. and Ruppert, D. (2011), to appear.
\end{References}
\printindex{}
\end{document}
